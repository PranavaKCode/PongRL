<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Pong RL Demo</title>
<style>
    body {
        background-color: #111;
        color: #eee;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        margin: 0;
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    .hud {
        width: 600px;
        display: flex;
        justify-content: space-between;
        font-size: 24px;
        font-weight: 700;
        margin-bottom: 10px;
    }
    .hud-left  { color: #4facfe; }  /* AI */
    .hud-right { color: #ff5f6d; }  /* YOU */
    canvas {
        background: #000;
        border: 2px solid #555;
        box-shadow: 0 0 40px rgba(0,0,0,0.8);
        cursor: none;
    }
    .instructions {
        margin-top: 10px;
        color: #888;
        font-size: 14px;
    }
</style>
</head>
<body>

<div class="hud">
    <span class="hud-left">AI: <span id="sAi">0</span></span>
    <span class="hud-right">YOU: <span id="sPl">0</span></span>
</div>

<canvas id="gameCanvas" width="600" height="400"></canvas>

<div class="instructions">
    Controls: <b>Arrow Keys</b> | Env: <b>Same as training</b>
</div>

<script>
// ---------- CONFIG ----------
const INITIAL_BALL_SPEED = 1.0;   // <--- tweak spawn speed here

// ---------- LOAD WEIGHTS ----------
let weights = null;

fetch("pong_brain.json")
  .then(r => r.json())
  .then(w => {
    weights = w;
    startGame();
  })
  .catch(err => {
    console.error("Failed to load pong_brain.json", err);
    alert("Error loading pong_brain.json â€“ check console.");
  });

// ---------- GAME CODE ----------
function startGame() {
  // ------ NEURAL NET ------
  function dense(input, w, b) {
      const out = new Array(b.length).fill(0);
      for (let i = 0; i < b.length; i++) {
          let s = 0;
          for (let j = 0; j < input.length; j++) s += input[j] * w[i][j];
          out[i] = s + b[i];
      }
      return out;
  }

  function relu(arr) { return arr.map(x => Math.max(0, x)); }

  function layerNorm(arr) {
      const mean = arr.reduce((a,b)=>a+b,0) / arr.length;
      const varc = arr.reduce((a,b)=>a+(b-mean)*(b-mean),0) / arr.length;
      const std = Math.sqrt(varc + 1e-5);
      return arr.map(x => (x - mean) / std);
  }

  function getAction(obs) {
      let x = dense(obs, weights.shared_0_w, weights.shared_0_b);
      x = relu(layerNorm(x));

      x = dense(x, weights.shared_3_w, weights.shared_3_b);
      x = relu(layerNorm(x));

      x = dense(x, weights.shared_6_w, weights.shared_6_b);
      x = relu(layerNorm(x));

      const logits = dense(x, weights.actor_w, weights.actor_b);

      let best = 0, bestVal = -Infinity;
      for (let i = 0; i < logits.length; i++) {
          if (logits[i] > bestVal) {
              bestVal = logits[i];
              best = i;
          }
      }
      return best;  // 0=stay, 1=up, 2=down
  }

  // ------ ENV / RENDER ------
  const LOGICAL_W = 84;
  const LOGICAL_H = 84;
  const PADDLE_H = 12;
  const PADDLE_W = 4;
  const BALL_SIZE = 3;
  const MAX_BALL_SPEED = 4.0;
  const PADDLE_SPEED = 1.5;

  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  const CANVAS_W = canvas.width;
  const CANVAS_H = canvas.height;
  const SX = CANVAS_W / LOGICAL_W;
  const SY = CANVAS_H / LOGICAL_H;

  const sAiEl = document.getElementById("sAi");
  const sPlEl = document.getElementById("sPl");

  let state = {
      ballX: LOGICAL_W / 2,
      ballY: LOGICAL_H / 2,
      ballVX: -INITIAL_BALL_SPEED,
      ballVY: 0.5,
      leftY:  LOGICAL_H / 2,  // YOU
      rightY: LOGICAL_H / 2,  // AI
      scoreL: 0,
      scoreR: 0
  };

  let keys = {up:false, down:false};
  window.addEventListener("keydown", e => {
      if (e.key === "ArrowUp")   { keys.up = true;   e.preventDefault(); }
      if (e.key === "ArrowDown") { keys.down = true; e.preventDefault(); }
  });
  window.addEventListener("keyup", e => {
      if (e.key === "ArrowUp")   keys.up = false;
      if (e.key === "ArrowDown") keys.down = false;
  });

  function resetBall(winner) {
      state.ballX = LOGICAL_W / 2;
      state.ballY = LOGICAL_H / 2;
      const dir = winner === "left" ? 1 : -1;
      state.ballVX = dir * INITIAL_BALL_SPEED;
      state.ballVY = (Math.random() - 0.5) * 2;
  }

  function update() {
      // player
      if (keys.up)   state.leftY  -= PADDLE_SPEED;
      if (keys.down) state.leftY  += PADDLE_SPEED;
      state.leftY  = Math.max(PADDLE_H/2, Math.min(LOGICAL_H - PADDLE_H/2, state.leftY));

      // AI
      const obs = [
          (state.ballX / LOGICAL_W) * 2 - 1,
          (state.ballY / LOGICAL_H) * 2 - 1,
          state.ballVX / MAX_BALL_SPEED,
          state.ballVY / MAX_BALL_SPEED,
          (state.leftY  / LOGICAL_H) * 2 - 1,
          (state.rightY / LOGICAL_H) * 2 - 1
      ];
      const action = getAction(obs);
      if (action === 1) state.rightY -= PADDLE_SPEED;
      if (action === 2) state.rightY += PADDLE_SPEED;
      state.rightY = Math.max(PADDLE_H/2, Math.min(LOGICAL_H - PADDLE_H/2, state.rightY));

      // ball physics
      state.ballX += state.ballVX;
      state.ballY += state.ballVY;

      if (state.ballY <= BALL_SIZE || state.ballY >= LOGICAL_H - BALL_SIZE) {
          state.ballVY *= -1;
          state.ballY = Math.max(BALL_SIZE, Math.min(LOGICAL_H - BALL_SIZE, state.ballY));
      }

      // left paddle
      if (state.ballX <= PADDLE_W + BALL_SIZE && state.ballVX < 0) {
          if (Math.abs(state.ballY - state.leftY) <= PADDLE_H/2 + BALL_SIZE) {
              state.ballVX *= -1.05;
              const rel = (state.leftY - state.ballY) / (PADDLE_H/2);
              state.ballVY -= rel * 0.5;
          }
      }

      // right paddle
      if (state.ballX >= LOGICAL_W - PADDLE_W - BALL_SIZE && state.ballVX > 0) {
          if (Math.abs(state.ballY - state.rightY) <= PADDLE_H/2 + BALL_SIZE) {
              state.ballVX *= -1.05;
              const rel = (state.rightY - state.ballY) / (PADDLE_H/2);
              state.ballVY -= rel * 0.5;
          }
      }

      const speed = Math.hypot(state.ballVX, state.ballVY);
      if (speed > MAX_BALL_SPEED) {
          const r = MAX_BALL_SPEED / speed;
          state.ballVX *= r;
          state.ballVY *= r;
      }

      // scoring
      if (state.ballX < 0) {
          state.scoreR++;
          sAiEl.textContent = state.scoreR;
          resetBall("right");
      }
      if (state.ballX > LOGICAL_W) {
          state.scoreL++;
          sPlEl.textContent = state.scoreL;
          resetBall("left");
      }
  }

  function draw() {
      ctx.fillStyle = "#111";
      ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

      ctx.strokeStyle = "#333";
      ctx.setLineDash([10, 15]);
      ctx.beginPath();
      ctx.moveTo(CANVAS_W/2, 0);
      ctx.lineTo(CANVAS_W/2, CANVAS_H);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.fillStyle = "#4facfe"; // AI paddle (right)
      ctx.fillRect(
          (LOGICAL_W - PADDLE_W) * SX,
          (state.rightY - PADDLE_H/2) * SY,
          PADDLE_W * SX,
          PADDLE_H * SY
      );

      ctx.fillStyle = "#ff5f6d"; // YOU paddle (left)
      ctx.fillRect(
          0,
          (state.leftY - PADDLE_H/2) * SY,
          PADDLE_W * SX,
          PADDLE_H * SY
      );

      ctx.fillStyle = "#fff";
      ctx.beginPath();
      ctx.arc(state.ballX * SX, state.ballY * SY, BALL_SIZE * ((SX+SY)/2), 0, Math.PI*2);
      ctx.fill();
  }

  function loop() {
      update();
      draw();
      requestAnimationFrame(loop);
  }

  loop();
}
</script>
</body>
</html>
